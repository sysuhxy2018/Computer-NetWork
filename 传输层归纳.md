# 传输层归纳

### 传输层

* 传输层提供进程间的通信。
* 传输层重要的两个协议是TCP和UDP。
* 传输层基本单元视不同协议分为报文段和用户数据报。



### UDP

用户数据报协议（UDP）特性：

* 无连接
* 尽最大可能交付
* 没有拥塞控制
* 面向报文（保留单个应用层报文，只添加首部）
* 支持多对多的交互通信



### TCP

传输控制协议（TCP）特性：

* 面向连接
* 可靠交付
* 流量，拥塞控制
* 面向字节流（将应用层报文视为字节流并拆分成数据块）
* 仅支持一对一交互通信（点对点）



> P.S. 下面部分的内容都是属于TCP的

### 三次握手

建立TCP连接需要三次传输数据的操作，简称“三次握手”。

三次握手需要用到的信息有：

* SYN，ACK。这两个都是1bit的标记值。
  * SYN设置为1，用于同步序号（可以认为是初始化）。在第一次发送报文段时SYN必设置为1。
  * ACK只在接收方成功接收报文段后发送回的响应报文段中设置为1，也就是除了第一次发送方发送报文外都设置为1。
* seq，ack。都是32bit（4字节）的字段。
  * seq为序号，表示发送的报文段编号。
  * ack为确认号，表示期望收到的下一个报文段编号。这个值通常为收到报文段的序号 + 收到报文段的数据长度。
    * ack只在ACK = 1时有效，ACK = 0时没有意义。

结合上面的理论，三次握手过程如下：

* 发送方（客户端）发送连接请求报文，**SYN = 1**, ACK = 0, seq = x, 不设置ack。
* 接收方（服务器）成功接收后，如果同意建立连接，发送确认报文。**SYN = 1, ACK = 1**, seq = y, ack = x + 1。
* 发送方收到确认报文后，再向接收方确认一次。SYN = 0，**ACK = 1**, seq = x + 1，ack = y + 1。
* 等到接收方收到确认后，正式建立连接。

注意发送方和接收方的seq实际上没有关联，都是独立的给各自的字节流编码得到报文段序号。

三次握手的原因：

实际上客户端在第二次握手后状态就已经是Established的了，而服务端要等收到第三次握手后才变为Established。之所以要进行多一次第三次握手，是为了防止重复打开连接。比如客户端第一次发送了一个连接请求但是滞留了，导致很长时间都没收到第二次握手；然后客户端就会因为超时重传机制重新请求，顺利到达并建立连接。然后这时第一次发送的连接才发送到服务器并进行第二次握手。如果有第三次握手，客户端检测到当前的状态已经是Established的了，就不会再进行第三次握手，那么服务器没收到第三次握手，就不会再重复打开连接。



### 四次挥手

关闭TCP连接需要四次传输数据的操作，简称“四次挥手”。

四次挥手需要用到的信息有：

* FIN，ACK。
  * FIN只在发送释放报文段时设置为1。在发送完FIN报文段后，就不能再发送数据了。（ACK报文段除外，它不是正式数据）
  * ACK在连接建立后全程都是1，直到正式关闭连接。
* seq，ack。
  * 同三次握手部分。

流程如下：

* 客户端发送连接释放报文段，这是客户端最后一次发送数据。**FIN = 1**, ACK = 1, seq = u, 没有ack。
* 服务器收到后发出确认，FIN = 0, **ACK = 1**, seq = v, ack = u + 1。
* 服务器同意关闭连接后，发送连接释放报文段，这是服务器最后一次发送数据。**FIN = 1, ACK = 1**, seq = w, ack = u + 1。
* 客户端收到报文段后再发送一次确认，FIN = 0, **ACK = 1**, seq = u + 1, ack = w + 1。然后进入Time-wait状态，等待2 MSL （最大报文存活时间）后释放连接。
* 服务器在收到客户端的确认后也释放连接，至此，连接正式关闭。

四次挥手原因：

* 对于服务器来说，在第二次挥手后进入Close-wait状态，可以让它继续发送未传输完的数据。当传输完成后，服务器才发送FIN连接释放报文段。所以我们需要第三次挥手。
* 对于客户端来说，在第三次挥手后要确认，所以需要第四次挥手。

Time-wait原因：

* 确保客户端留出足够的时间处理服务器超时重传的FIN报文段（第三次挥手）。因为服务器如果没能及时收到第四次挥手的ACK报文段，就会再发一次FIN报文段。如果客户端早早关闭了，就不能再接收处理了。
* 确保此次连接内所有报文段都从网络上消失，通俗点就是“耗死”所有报文段。



### 补充

* TCP通过超时重传实现可靠传输。
* TCP通过接收方ACK报文段中的窗口字段来控制发送方窗口大小，从而控制发送方速率，降低拥塞可能。
* TCP拥塞控制是为了降低网络的拥塞程度，避免分组丢失。（因为如果分组迟迟不能交付，过了最大存活时间就会消失）
  * 主要原理是四个算法
    * 慢开始，cwnd（拥塞窗口）从1倍增
    * 拥塞避免，cwnd >= ssthresh（慢开始阈值） 时++，发生超时后ssthresh = cwnd / 2, cwnd = 1
    * 快重传，发送方收到3个连续的重复确认，说明下一报文段丢失。马上重传丢失报文段。
    * 快恢复，ssthresh = cwnd / 2，由于没有超时，所以cwnd可以大一些，从ssthresh开始直接++。














# HTTP归纳

### 请求方法

* GET，用于获取资源，最常用
* HEAD，类似于GET，但是只有报文首部，没有实体主体。
* POST，用于传输实体主体数据。
* PUT，上传文件。存在安全性问题，慎用
* DELETE，删除文件。



### 响应状态码

* 200 OK。请求成功。
* 204 No Content。
  * 请求成功处理，但是响应报文不包含实体主体，即没有数据返回。
  * 场景：服务器通知浏览器继续显示原来的文档，没有更新的文档。
* 302 Found。临时性重定向。
* 304 Not Modified。
  * 场景：服务器通知浏览器，原来的缓存文档可以继续使用。和文档缓存机制有关。
* 403 Forbidden。请求被拒绝。
* 404 Not Found。服务器找不到请求的页面。
* 500 Internal Server Error。请求未完成，一般可能是服务器运行的程序/脚本出错了。
* 503 Service Unavailable。请求未完成，服务器临时过载或宕机。



### HTTP连接

从HTTP/1.1开始默认都是长连接的，即建立一次TCP连接就能进行多次HTTP通信。



### Cookie&Session

由于HTTP是无状态的，所以引入Cookie来保存状态信息。

Cookie存放在客户端主机（本地）。一般在浏览器第一次请求服务器时创建，服务器的响应报文中包含Set-Cookie首部字段，浏览器收到后将cookie内容保存在本地。之后浏览器每次请求该服务器，都会从本地取出Cookie信息并在请求报文中包含Cookie首部字段。

Cookie可分为两类：

* 会话期Cookie。浏览器关闭后会被自动删除，一般存放在内存中。
* 持久性Cookie。浏览器关闭后不会被清除，因为存放在硬盘中。会指定有效期，过期就会被删除。

Cookie的一些属性：

* Domain，指定可以访问该Cookie的服务器主机，包含Domain域名和Domain的子域名。浏览器在访问不同主机的时候会引用不同的Cookie。
* Path，指定服务器主机上可以访问该Cookie的目录，包含Path目录和Path的子目录。浏览器在访问同一个主机的不同路径时，会引用不同的Cookie。
* HttpOnly，表明该Cookie无法被JavaScript脚本调用。可以预防跨站脚本攻击（XSS）。
* Secure，表明该Cookie只能通过HTTPS安全协议发送。

另外还有一种存储信息的方式是Session。

Session存放在服务器上，可以是内存、硬盘或者数据库等等。其实现分为两种：

* 基于Cookie的。也是在浏览器第一次请求服务器时创建Cookie，只不过Cookie里保存的只有Session ID而不是直接存储用户信息。之后访问的时候，服务器收到含有Session ID的Cookie的请求，会提取出ID并找到ID对应的用户信息。
* 如果浏览器禁用Cookie，那么Session ID只能通过URL参数进行传递。

Cookie和Session的比较：

* Cookie只能存储ASCII码字符串，而Session支持任何类型数据。
* Cookie存储在客户端本地，能够被浏览器引用，所以有被恶意窃取的风险。
* 如果都用Session存储，服务器需要花费很多开销；用Cookie则不需要服务器承担。

建议将一些小的，简单的，不重要的用Cookie存储；大的，复杂的，隐私的内容用Session存储。



### 缓存

缓存可以缓解服务器压力，加快客户端获取资源的速率。

缓存分为两类：

* 存储在客户端本地。
* 存储在代理服务器上。

缓存机制用到的一些首部字段：

* Cache-Control：控制缓存。如是否禁用（no-store），以及缓存能保存的时间长度（max-age)等。
* Expire：记录缓存资源过期的时间戳。不过一般检查是否过期用的是上面的max-age。
* ETag & If-None-Match，这两个通常配套使用。
  * 服务器在响应报文中会加入ETag首部字段，它是资源的唯一标识。
  * 下次浏览器再请求的时候就在If-None-Match首部加入已缓存资源的ETag值。服务器收到请求后，检查该ETag值和最新资源的Etag值是否一致，如果一致则表示浏览器可以继续用原来的缓存资源，并返回304状态码。
* Last-Modified & If-Modified-Since，这两个也是一组。不过检查资源是否最新一般用上面的ETag，Last-Modified的精确度不够。
  * 服务器在响应报文中会加入对资源的最后修改时间的时间戳（精确到秒）。
  * 下次浏览器再请求的时候就在If-Modified-Since首部中加入这个时间戳。服务器收到请求后，检查该时间戳和请求资源的最新修改时间是否一致，则可以认为资源没有再修改过，可以继续用缓存资源，并返回304状态码。

总的来说就是先检查缓存是否过期，没过期再检查缓存资源是否最新。



### 补充

* Vary响应首部字段用于代理缓存服务器的管理信息，从而实现内容协商。也就是说，代理缓存服务器会根据Vary设置的检查标准检查服务器上缓存是否满足该标准，如果满足，就可以返回缓存；不满足，需要重新向源服务器请求资源。
  * 如客户端第一次发送了包含Accept-Language首部字段的请求，缓存服务器没有缓存，直接向源服务器请求，源服务器返回的响应为：Vary: Accept-Language。缓存服务器缓存后将资源返回给客户端。客户端下一次再请求相同URL的资源时，缓存服务器会检查缓存资源的Accept-Language字段和请求的Accept-Language字段是否一致，一致则直接返回缓存，不一致则向源服务器重新请求。
  * Vary其实相当于上面缓存机制的补充，即增加了额外条件判断缓存是否能够使用。
* 一份报文实体主体可包含多种不同类型的实体同时发送，每部分都有独立的实体首部字段和实体主体。
  * 如一个上传多个表单的报文的Content-Type实体首部字段设置为multipart/form-data时，其实体主体可包含多个实体。
* 代理服务器除了有缓存的作用外，还可以用于负载均衡。
  * 负载均衡简单来说就是将用户的请求平衡、分摊到多个服务器上处理。
  * 代理服务器可以将请求均匀转发给多台服务器，从而实现负载均衡。
  * 一些负载均衡算法：
    * 轮询法
    * 随机法
    * 最小连接法

